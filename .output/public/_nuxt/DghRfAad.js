import{P as O,q as p,Q as H,E as b,G as j,R,S as E,T as D,U as M,V as N,W as I,M as K,X as S,Y as U,Z as C,N as v,$ as x,x as z,a0 as T,a1 as W,a2 as $,a3 as q}from"./DTcdeyfU.js";function F(n,r={}){const e=r.head||O();if(e)return e.ssr?e.push(n,r):G(e,n,r)}function G(n,r,e={}){const c=p(!1),a=p({});H(()=>{a.value=c.value?{}:M(r)});const t=n.push(a.value,e);return b(a,d=>{t.patch(d)}),D()&&(j(()=>{t.dispose()}),R(()=>{c.value=!0}),E(()=>{c.value=!1})),t}const L=n=>n==="defer"||n===!1;function Q(...n){var P;const r=typeof n[n.length-1]=="string"?n.pop():void 0;typeof n[0]!="string"&&n.unshift(r);let[e,c,a={}]=n;if(typeof e!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof c!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=v(),h=c,d=()=>null,l=()=>t.isHydrating?t.payload.data[e]:t.static.data[e];a.server=a.server??!0,a.default=a.default??d,a.getCachedData=a.getCachedData??l,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??N.deep,a.dedupe=a.dedupe??"cancel";const u=()=>a.getCachedData(e,t)!=null;if(!t._asyncData[e]||!a.immediate){(P=t.payload._errors)[e]??(P[e]=null);const i=a.deep?p:I;t._asyncData[e]={data:i(a.getCachedData(e,t)??a.default()),pending:p(!u()),error:K(t.payload._errors,e),status:p("idle")}}const s={...t._asyncData[e]};s.refresh=s.execute=(i={})=>{if(t._asyncDataPromises[e]){if(L(i.dedupe??a.dedupe))return t._asyncDataPromises[e];t._asyncDataPromises[e].cancelled=!0}if((i._initial||t.isHydrating&&i._initial!==!1)&&u())return Promise.resolve(a.getCachedData(e,t));s.pending.value=!0,s.status.value="pending";const y=new Promise((f,o)=>{try{f(h(t))}catch(m){o(m)}}).then(async f=>{if(y.cancelled)return t._asyncDataPromises[e];let o=f;a.transform&&(o=await a.transform(f)),a.pick&&(o=X(o,a.pick)),t.payload.data[e]=o,s.data.value=o,s.error.value=null,s.status.value="success"}).catch(f=>{if(y.cancelled)return t._asyncDataPromises[e];s.error.value=x(f),s.data.value=z(a.default()),s.status.value="error"}).finally(()=>{y.cancelled||(s.pending.value=!1,delete t._asyncDataPromises[e])});return t._asyncDataPromises[e]=y,t._asyncDataPromises[e]},s.clear=()=>V(t,e);const _=()=>s.refresh({_initial:!0}),B=a.server!==!1&&t.payload.serverRendered;{const i=D();if(i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const o=i._nuxtOnBeforeMountCbs;S(()=>{o.forEach(m=>{m()}),o.splice(0,o.length)}),U(()=>o.splice(0,o.length))}B&&t.isHydrating&&(s.error.value||u())?(s.pending.value=!1,s.status.value=s.error.value?"error":"success"):i&&(t.payload.serverRendered&&t.isHydrating||a.lazy)&&a.immediate?i._nuxtOnBeforeMountCbs.push(_):a.immediate&&_();const y=T();if(a.watch){const o=b(a.watch,()=>s.refresh());y&&C(o)}const f=t.hook("app:data:refresh",async o=>{(!o||o.includes(e))&&await s.refresh()});y&&C(f)}const g=Promise.resolve(t._asyncDataPromises[e]).then(()=>s);return Object.assign(g,s),g}function V(n,r){r in n.payload.data&&(n.payload.data[r]=void 0),r in n.payload._errors&&(n.payload._errors[r]=null),n._asyncData[r]&&(n._asyncData[r].data.value=void 0,n._asyncData[r].error.value=null,n._asyncData[r].pending.value=!1,n._asyncData[r].status.value="idle"),r in n._asyncDataPromises&&(n._asyncDataPromises[r].cancelled=!0,n._asyncDataPromises[r]=void 0)}function X(n,r){const e={};for(const c of r)e[c]=n[c];return e}const w="__nuxt_component";async function Y(n,r){const e=v(),c=W(),a=D(),{fetchKey:t,_fetchKeyBase:h}=a.proxy.$options,d=(typeof t=="function"?t(()=>""):t)||[h,c.fullPath,c.matched.findIndex(s=>Object.values(s.components||{}).includes(a.type))].join(":"),{data:l,error:u}=await Q(`options:asyncdata:${d}`,()=>e.runWithContext(()=>r(e)));if(u.value)throw x(u.value);l.value&&typeof l.value=="object"&&Object.assign(await n,$(q(l.value)))}const J=function(...r){const[e,c]=r,{setup:a}=e;return!a&&!e.asyncData&&!e.head?{[w]:!0,...e}:{[w]:!0,_fetchKeyBase:c,...e,setup(t,h){const d=v(),l=a?Promise.resolve(d.runWithContext(()=>a(t,h))).then(s=>s||{}):{},u=[];if(e.asyncData&&u.push(Y(l,e.asyncData)),e.head){const s=v();F(typeof e.head=="function"?()=>e.head(s):e.head)}return Promise.resolve(l).then(()=>Promise.all(u)).then(()=>l).finally(()=>{u.length=0})}}};export{J as d};
